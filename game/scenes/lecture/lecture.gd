extends Control

# class member variables go here, for example:
# var a = 2
# var b = "textvar"

func _ready():
	# Called every time the node is added to the scene.
	# Initialization here
	var lec = get_node("Sprite/RichTextLabel")
  
	lec.set_text("Лекция N 1\n" +
"\n" +
"                        \"Язык программирования С++\n" +
"\n" +
"С++ был разработан на основе языка программирования С и сохраняет его\n" +
"как подмножество.\n" +
"Язык программирования С был разработан Денисом Ричи в лаборатории\n" +
"фирмы Bell в начале семидесятых годов. Одна из первоначальных целей создания\n" +
"языка С - замена ассемблера в задачах системного программирования. Поэтому в\n" +
"этом языке есть такие средства, как указатели, побитовые операции, операции\n" +
"поразрядного сдвига. На этом языке была разработана операционная система UNIX для мини-ЭВМ PDP-11.\n" +
"Однако именно те средства, которые позволяют на С писать мощные и\n" +
"компактные программы делают его беззащитным для целого класса ошибок, от\n" +
"которых есть защита в других языках программирования.\n" +
"С++ является расширением языка С. Основная цель этого расширения -\n" +
"поддержка объектно-ориентированного программирования. Ключевым понятием C++ является класс. Кроме того там есть еще ряд средств, которые не относятся\n" +
"непосредственно к объектно-ориентированному программированию, такие как\n" +
"перегрузка операций и функций, inline-функции и так далее. С++ более типизирован и более защищен от ошибок, чем С.\n" +
"Изложение языка С++ будет сделано в 2 этапа: вначале быстрое, не совсем\n" +
"формальное введение в С++ на примерах задач, которое позволит сразу же начать\n" +
"программирование, а затем последующее изложение остального.\n" +
"\n" +
"Следующая программа осуществляет вывод на экран монитора сообщения\n" +
"\"Hello, hello!\".\n" +
"\n" +
"#include <stdio.h>\n" +
"void main(void)\n" +
"{\n" +
"  \"printf(\"Hello, hello!\n\");\n" +
"}\n" +
"\n" +
"Прокомментируем эту программу. Все строки, которые начинаются с\n" +
"символа \"#\" -  это директивы препроцессора. Препроцессор – это программа, которая предварительно преобразует (препроцессирует) текст программы, после чего передает его компилятору. В данном случае эта директива сообщает препроцессору, что вместо нее необходимо вставить содержимое файла stdio.h (header файла, заголовочного файла). Все функции в языке С разбиты на отдельные группы. Для каждой группы функций необходим свой заголовочный файл, в котором находятся\n " +
"прототипы этих функций (то есть описания правильного обращения к функциям), определения необходимых структур данных, различных констант. Файл stdio.h \n" +
"поддерживает работу функций, обеспечивающих стандартный ввод-вывод высокого уровня.\n" +
"Вторая строка сообщает компилятору, что это основная (главная) функция п при запуске программы именно ей будет передано управление. Первое ключевое слово void говорит о том что эта функция не возвращает после окончания работы никакого значения, второе слово – что при запуске функции из командной строки ей не \n" +
"осуществляется передача аргументов. Тело функции ограничено фигурными скобками.\n" +
"Четвертая строка - это оператор-выражение, обращение к функции вывода printf. Эта функция выводит форматную строку, заключенную в \"\" на дисплей. Строка \n" +"выводится в то место, где в данный момент находится курсор. Тот же самый результат был бы и в следующем случае:\n" +
"\n" +
"  \"printf(\"Hello, \");\n" +
"  \"printf(\"hello!\n\");\n" +
"\n" +
"где \\n - это управляющий символ. Символ \"\\" + 
" всегда рассматривается вкупе со следующим за ним символом. Наиболее используемые управляющие символы:\n" +
"\n - перевод строки;\n" +
"\r - возврат каретки;\n" +
"\t - горизонтальная табуляция;\n" +
"\v - вертикальная табуляция;\n" +
"\f - перевод формата.\n" +
"\n" +
"В языке С каждый оператор завершается символом \";\". В языке С прописные и строчные символы - это разные символы.\n" +
"Следует заметить, что в языке С ввод-вывод поддерживается не операторами, а функциями.\n" +
"Более подробное описание ввода-вывода приведено в лекции 8 и приложении 01.\n" +
"Вывод в этой программе может быть реализован и по другому: с помощью тех средств, которые появились в С++.\n" +
"\n" +
"#include <iostream.h>\n" +
"void main (void)\n" +
"{\n" +
"  \"cout << \"Hello, World!\n\";\n" +
"}\n" +
"\n" +
"        \"Файл iostream.h содержит описания классов (типов данных), перегруженных\n" +
"операций, необходимых для поддержки стандартных потоков ввода-вывода С++.\n" +
"Без этих описаний выражение\n" +
"\n" +
"cout << \"Hello, World!\n\"\n" +
"\n" +
"не имело бы смысла. Перегруженная операция << (в языке С - это операция\n" +
"поразрядного сдвига влево) записывает значение своего второго параметра в первый параметр. В данном случае строка \"Hello, World!\n\" записывается в \n" +"стандартный выходной поток cout (console out). Строка - это последовательность символов, заключенная в двойные кавычки.\n" +
"Более подробное описание этого типа ввода-вывода приведено в приложениях 02 и 03.\n" +
"\n" +
"                        \"Оператор цикла WHILE\n" +
"\n" +
"Синтаксис\n" +
"\n" +
"while (выражение)\n" +
"     \"оператор;\n" +
"\n" +
"        \"Оператор выполняется до тех пор, пока значение выражения не станет ЛОЖЬ. В этом случае управление передается следующему оператору.\n" +
"-----------------------------------------------------------------------------------------------------------\n" +
"!!!   В языке С значение выражения -  ИСТИНА, если оно отлично от нуля.  !!!\n" +
"-----------------------------------------------------------------------------------------------------------\n" +
"Если в цикле должны выполняться несколько операторов, то они объединяются в составной оператор с помощью фигурных скобок {}.\n" +
"Все условные выражения в языке С++ обязательно заключаются в ().\n" +
"Следующая программа осуществляет печать таблицы площадей кругов в зависимости от радиуса.\n" +
"R = 1 (1) 20\n" +
"\n" +
"#include <stdio.h>\n" +
"#include <conio.h>\n" +
"void main(void)\n" +
"{\n" +
"  \"int r;\n" +
"  \"float s;\n" +
"  \"r=1:\n" +
"  \"clrscr();\n" +
"  \"while (r<=20)\n" +
"  {\n" +
"    \"s=3.1416*r*r;\n" +
"    \"printf(\"For r=%2d   s=%7.2f\n\",r,s);\n" +
"    r=r+1;\n" +
"  \"}\n" +
"  \"getch();\n" +
"}\n" +
"	\"Для функций clrscr() – очистка экрана и getch() – чтение кода нажатой клавиши необходим заголовочный файл conio.h. Функция getch() в данном примере \n" +"используется для ее приостановки программы до нажатия любой клавиши.\n" +
"\n" +
"\n" +
"Стандартная ошибка начинающих:\n" +
"\n" +
"while (r<=20);\n" +
"\n" +
"В этом случае в цикле выполняется пустой оператор и программа зацикливается.    \n" +
"Что нового появилось в этой программе?\n" +
"В этой программе появились определения типов данных. В С существуют\n" +
"следующие основные встроенные типы данных.\n" +
"\n" +
"Знаковые целочисленные типы данных:\n" +
"\n" +
"Тип		Размер	Диапазон значений\n" +
"[signed] char		1 байт		-128 … 127\n" +
"[signed] short [int]	2 байта	-32 768 … 32 767\n" +
"[signed] int		2 байта	-32 768 … 32 767\n" +
"[signed] long  [int]	4 байта	-2 147 483 648 … 2 147 483 647\n" +
"\n" +
"[]  обозначают необязательность написания данного элемента.\n" +
"\n" +
"Беззнаковые целочисленные типы:\n" +
"\n" +
"Тип		Размер	Диапазон значений\n" +
"unsigned char	1 байт		0 … 255\n" +
"unsigned short [int]	2 байта	0 … 65 535\n" +
"unsigned [int]	2 байта	0 … 65 535\n" +
"unsigned long  [int]	4 байта	0 …  4 294 967 295\n" +
"\n" +
"Вещественные типы:\n" +
"\n" +
"Тип		Размер	Диапазон значений\n" +
"float			4 байта	3.4e-38 … 3.4e+38\n" +
"double			8 байт		1.7e-308 … 1.7e+308\n" +
"long double		10 байт	3.4e4932 … 3.4e+4932\n" +
"\n" +
"	\"Для вещественных типов в таблице приведены абсолютные величины минимальных и максимальных значений.\n" +
"	Следует отметить, что на других платформах может быть другой размер типа int. Для его получения необходимо пользоваться операцией sizeof, результатом\n " +
" которой является размер типа в байтах. Например, в операционной системе MS-DOS sizeof(int) дает результат 2, а в Widows XP результатом будет 4.\n" +
"\n" +
"Следующие арифметические операции можно использовать над любым сочетанием перечисленных типов:\n" +
"\n" +
"+    (сложение)\n" +
"++   (сложение инкрементальное)\n" +
"-    (вычитание)\n" +
"--   (вычитание инкрементальное)\n" +
"*    (умножение)\n" +
"/    (деление)\n" +
"%    (остаток от деления)\n" +
"\n" +
"То же верно для операций отношения:\n" +
"\n" +
"==   (равно)\n" +
"!=   (не равно)\n" +
"<    (меньше чем)\n" +
"<=   (меньше или равно)\n" +
">=   (больше или равно)\n" +
"\n" +
"Результат операций отношения нормализован: 0 - ложь, 1 - истина, их значения можно использовать точно так же, как и прочие числовые. Например:\n" +
"\n" +
"y=10+(x>1);  \n" +
"\n" +
"Результат будет 11, если x>1 и 10, в противном случае.\n" +
"\n" +
"Символ = обозначает операцию присваивания, а == операцию проверки на равенство. При освоении Си часто вместо == пишут =, что приводит к логическим ошибкам, \n" +"например:\n" +
"\n" +
"while(x=1)\n" +
"{  ...   }\n" +
"\n" +
"Этот цикл будет выполняться бесконечно, поскольку x присваивается значение 1 и значение условного выражения всегда будет “истина”.\n" +
"Операции инкремента ++ и декремента -- могут быть как префиксные, так и постфиксные. Если операция префиксная, то значение переменной изменяется на 1 до \n" +"использования в выражении, если постфиксная, то после использования.\n" +
"        \"Например\n" +
"\n" +
"int i=1;\n" +
"cout<<++i;   //2\n" +
"cout<<i;       //2\n" +
"cout<<i--;    //2\n" +
"cout<<i;      //1\n" +
"\n" +
"В арифметических выражениях можно использовать числовые значения\n" +
"различных типов. При вычислении используются стандартные преобразования типов (смотри конец 2-ой лекции).\n" +
"\n" +
"double d=1;\n" +
"int i=10;\n" +
"short s=5;\n" +
" \"...\n" +
"d=d+(i=s+i);\n" +
"\n" +
"                        \"Оператор цикла do-while\n" +
"\n" +
"Синтаксис\n" +
"\n" +
"do\n" +
"    \"оператор;\n" +
"while (выражение);\n" +
"\n" +
"       \"Оператор выполняется до тех пор, пока значение выражения не станет ЛОЖЬ (то есть 0). В этом случае управление передается следующему оператору.\n" +
"        \"Значение выражения проверяется после выполнения оператора. Поэтому оператор выполняется хотя бы один раз.\n" +
"        Оператор do-while проверяет условие в конце  цикла.\n" +
"        \"Оператор    while проверяет условие в начале цикла.\n" +
"        \"Пример:\n" +
"\n" +
"   \". . .\n" +
"x=1;\n" +
"do\n" +
"    \"printf(\"%d\n\",func(x,2));\n" +
"while (++x<=7);\n" +
"\n" +
" 		\"Оператор цикла for\n" +
"\n" +
"Синтаксис\n" +
"\n" +
"for (выражение1; выражение2; выражение3)\n" +
"    \"оператор;\n" +
"\n" +
"Выполнение оператора for эквивалентно выполнению последовательности\n" +
"следующих операторов:\n" +
"\n" +
"выражение1;\n" +
"while (выражение2)\n" +
"{\n" +
"    \"оператор;\n" +
"    \"выражение3;\n" +
"}\n" +
"\n" +
"Ниже приведена программа для решения той же задачи, только с использованием оператора цикла for.\n" +
"\n" +
"#include <stdio.h>\n" +
"#include <conio.h>\n" +
"{\n" +
"  \"int r;\n" +
"  \"float s;\n" +
"  \"clrscr();\n" +
"  \"for (r=1;r<=20;r++)\n" +
"  {\n" +
"    \"s=3.1416*r*r;\n" +
"    \"printf(\"For r=%2d   s=%7.2f\n\",r,s);\n" +
"  }\n" +
"  \"getch();\n" +
"}\n" +
"	\n" +
"	\"Данную программу можно записать более кратко, поместив все действия в оператор for, используя операцию “,” (последовательное вычисление подвыражений). Но \n" +"лучше так не делать, так как текст стал гораздо менее читабельным.\n" +
"\n" +
" \"#include <stdio.h>\n" +
"\\#include <conio.h>\n" +
"void main(void)\n" +
"{\n" +
"  \"clrscr();\n" +
"  \"for (int r=1;r<=20;printf(\"For r=%2d   s=%7.2f\n\",r,3.1416*r*r),r++);\n" +
"  \"getch();\n" +
"}\n" +
"\n" +
"	\"В этой программе переменная  r определена внутри цикла. Подобная конструкция является типичной для языка С++. Переменная, описанная в операторе цикла, \n" +"видна только внутри этого цикла. В некоторых реализациях компиляторов видимость простирается до конца блока программы (в частности в Visual Studio), но \n" +"это не является стандартом языка С++.\n" +
"\n" +
"                        \"Условный оператор if - else\n" +
"\n" +
"Синтаксис (1 вариант)\n" +
"\n" +
"if (выражение)\n" +
"    \"оператор;\n" +
"\n" +
"Если значение выражения - истинно, то выполняется один единственный оператор (простой или составной), иначе этот оператор пропускается и выполняется \n" +"следующий за ним оператор.\n" +
"\n" +
"Синтаксис (2 вариант)\n" +
"\n" +
"if (выражение)\n" +
"    \"оператор1;\n" +
"else\n" +
"    \"оператор2;\n" +
"\n" +
"	\"В зависимости от истинности значения выражения выполняется или оператор1 или оператор2.\n" +
"        \"В следующем примере показано преобразование дюйма в сантиметр и обратно. Предполагается, что во входном потоке значение в сантиметрах завершается  \n" +"символом i, а значение в дюймах - символом c:\n" +
"\n" +
"#include <iostream.h>\n" +
"void main (void)\n" +
"{\n" +
"  \"float x, in, cm;\n" +
"  char ch;\n" +
"  \"cout << \"enter length: \";\n" +
"  \"cin >> x;                  // ввод числа с плавающей точкой\n" +
"  \"cin >> ch;                // ввод завершающего символа\n" +
"  if (ch=='i')\n" +
"  \"{                               // дюйм\n" +
"      in=x;\n" +
"      \"cm=x*2.54;\n" +
"  }\n" +
"  \"else if (ch=='c')\n" +
" \"{                                // сантиметры\n" +
"      in=x/2.54;\n" +
"      \"cm=x;\n" +
" }\n" +
"  else\n" +
"      \"in=cm=0;\n" +
"  \"cout << in << \"in = \" << cm << \"cm\n\";\n" +
"}\n" +
"\n" +
"В этом примере появляется задание символьной константы, то есть константы, значение которой равняется коду символа. Символьная константа задается с помощью \n" +"одинарных кавычек, ограничивающих конкретный символ. В данном примере это 'i'.\n" +
"\n" +
"                        \"Оператор-переключатель switch\n" +
"\n" +
"Синтаксис\n" +
"\n" +
"switch (целочисленное выражение)\n" +
"{\n" +
"   \"case целочисленная_константа1:\n" +
"       операторы\n" +
"   \"[case целочисленная_константа2:\n" +
"       \"операторы]\n" +
". . .\n" +
"   \"[default:\n" +
"       \"операторы]\n" +
"}\n" +
"	\"[] обозначают необязательность конструкции,  . . . – возможность многократного повторения.\n" +
"Оператор switch (переключатель) сравнивает значение выражения с набором\n" +
"констант во всех ветвях case и передает управление первоиу оператору в той ветви, которая соответсвует значению выражения. Если такого соответствия нет, то управление передается ветви default, если она есть. Если ветви default не окажется, то никаких действий не будет выполнено. Ключевые слова case  вместе с\n " + 
"константами служат просто метками, и если будут выполняться операторы для некоторого варианта case, то далее будут выполняться операторы всех последующих \n" +"вариантов до тех пор, пока не встретиться оператор break. Это позволяет связывать одну последовательность операторов с несколькими вариантами.\n" +
"Значения выражений и констант должны быть целочисленного типа.\n" +
"if-else в предыдущем примере можно заменить на switch следующим образом:\n" +
"\n" +
"    \". . .\n" +
"switch (ch)\n" +
"{\n" +
"  \"case 'i':\n" +
"    \"in=x;\n" +
"    \"cm=x*2.54;\n" +
"    \"break;\n" +
"  \"case 'c':\n" +
"    \"in=x/2.54;\n" +
"    \"cm=x;\n" +
"    \"break;\n" +
"  \"default:\n" +
"    \"in=cm=0;\n" +
"}\n" +
"    \". . .\n" +
"\n" +
"Операторы break используются для выхода из переключателя. Пример\n" +
"связи операторов с несколькими ветвями приведен ниже:\n" +
"\n" +
"    \". . .\n" +
"switch (x)\n" +
"{\n" +
"  \"case 'A':\n" +
"    \"printf(\"CASE A\n\");\n" +
"    break;\n" +
"  \"case 'B':\n" +
"  \"case 'C':\n" +
"    \"printf(\"CASE B or C\n\");\n" +
"    break;\n" +
"  \"default:\n" +
"    \"printf(\"NOT A, B or C\n\");\n" +
"}\n" +
"    \". . .\n" +
"\n" +
"                        \"Оператор break\n" +
"\n" +
"Синтаксис\n" +
"\n" +
"break;\n" +
"\n" +
"Прекращает выполнение ближайшего вложенного внешнего оператора switch,\n" +
"while, do или for. Этот оператор вызывает немедленный выход из самого внутреннего из объемлющих его циклов или переключателей. Управление передается \n" +
"первому оператору, следующему за ними. Одно из назначений этого оператора - закончить выполнение цикла при достижении внутри тела цикла некоторого условия.\n" +
"      \"Например:\n" +
"\n" +
"    \". . .\n" +
"for (i=0;i<n;i++)\n" +
"  \"if ((a[i]=b[i])==0)\n" +
"    break;\n" +
"    \". . .\n" +
"\n" +
"В данном примере элементы массива b переписываются в массив a до тех\n" +
"пор, пока очередное переписываемое значение не окажется нулем.\n" +
"\n" +
"                        \"Оператор continue\n" +
"\n" +
"Синтаксис\n" +
"\n" +
"continue;\n" +
"\n" +
"Этот оператор в чем-то похож на break, но применяется гораздо реже. Он вынуждает ближайщий объемлющий ее цикл (for, while или do-while) начать следующий шаг\n " +
"итерации. Для while и do-while это означает немедленный переход к проверке условия, а для for - к приращению шага (то-есть к вычислению 3-го выражения).\n" +
"Ниже приведен пример использования этого оператора:\n" +
"\n" +
"    \". . .\n" +
"for (i=0;i<n;i++)\n" +
"{\n" +
"    \"if (a[i]!=0)\n" +
"      \"continue;\n" +
"    \"a[i]=b[i];\n" +
"    \". . .\n" +
"}\n" +
"\n" +
"        \"В этом примере нулевые значения массива a заменяются значениями\n" +
"соответствующих элементов массива b.\n" +
"\n" +
"                        \"Оператор-выражение\n" +
"\n" +
"Любое выражение, заканчивающееся точкой с запятой (;), является\n" +
"оператором. Ниже приведены примеры операторов-выражений:\n" +
"\n" +
"x=3;\n" +
"printf(\"Для продолжения работы нажмите любую клавишу.\n\");\n" +
"getch();\n" +
"\n" +
"                        \"Составной оператор\n" +
"\n" +
"Составной оператор (блок) состоит из одного или более операторов любого типа, заключенных в фигурные скобки ({}). После закрывающей скобки не надо ставить \n" +"«;» (хотя это можно и сделать и это не будет зафиксировано как ошибка). Пример:\n" +
"\n" +
"{\n" +
"  \"x=1;\n" +
"  \"y=2;\n" +
"  \"z=3;\n" +
"}\n" +
"\n" +
"                        \"Пустой оператор\n" +
"\n" +
"Состоит только из точки с запятой (;). То есть если мы в предыдущем случае после «}» поставим «;» - это будет просто пустой оператор.\n" +
"\n" +
"                        \"Метка оператора\n" +
"\n" +
"Метка может стоять перед любым оператором, для того чтобы этому оператору можно было передать управление с помощью оператора goto. Метка состоит из \n" +"идентификатора, за которым стоит двоеточие (:). Областью определения метки является данная функция. Пример метки:\n" +
"\n" +
"ABCD2: x=3;\n" +
"\n" +
"                        \"Оператор перехода goto\n" +
"\n" +
"Синтаксис\n" +
"\n" +
"goto метка;\n" +
"\n" +
"Управление передается на оператор с меткой \"метка\". Область действия ограничена текущей функцией. Пример:\n" +
"\n" +
"goto ABCD2;\n" +
"// . . .\n" +
"ABCD2:  оператор;\n" +
"\n" +
"Метка и goto являются анахронизмами, пришедшими из языков неструктурного программирования, но в ряде случаев они бывают удобны. Например:\n" +
"--  выход сразу из нескольких вложенных циклов;\n" +
"--  переход из нескольких мест функции в одно.\n" +
"\n" +
"                        \"Оператор возврата return\n" +
"\n" +
"Синтаксис\n" +
"\n" +
"return;\n" +
"\n" +
"Прекращает выполнение текущей функции и возвращает управление вызвавшей программе без передачи значения.\n" +
"\n" +
"Синтаксис\n" +
"\n" +
"return выражение;\n" +
"\n" +
"Прекращает выполнение текущей функции и возвращает управление\n" +
"вызвавшей программе с передачей значения \"выражения\". Пример:\n" +
"\n" +
"return x+y;\n" +
"\n")
	lec.set_scroll_follow(true)

